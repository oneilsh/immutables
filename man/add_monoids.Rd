% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/30-api-flexseq-add-monoids.R
\name{add_monoids}
\alias{add_monoids}
\title{Add/merge monoids on an existing tree}
\usage{
add_monoids(t, monoids, overwrite = FALSE)
}
\arguments{
\item{t}{FingerTree.}

\item{monoids}{Named list of `measure_monoid` objects to add.}

\item{overwrite}{Logical; whether overlapping names replace existing monoids.}
}
\value{
A persistent copy with recomputed cached measures.
}
\description{
Add/merge monoids on an existing tree
}
\details{
`add_monoids()` is the advanced user-facing API for attaching custom monoids
after constructing a structure.

The `measure(el)` input shape depends on structure type:

- `flexseq`: payload element.
- `priority_queue`: entry list with `item` and `priority`.
- `ordered_sequence`: entry list with `item` and `key`.
- `interval_index`: entry list with `item`, `start`, and `end`.
}
\examples{
# Common workflow:
# 1) construct structure
# 2) attach monoid with add_monoids()
# 3) query with split_around_by_predicate()

# flexseq: split a stream by cumulative token budget
tokens <- as_flexseq(c(120, 80, 50, 200))
token_sum <- measure_monoid(`+`, 0, as.numeric)
budgeted <- add_monoids(tokens, list(token_sum = token_sum))
cut <- split_around_by_predicate(budgeted, function(v) v > 200, "token_sum")
cut$left   # still within budget
cut$elem   # first element that crosses budget
cut$right  # remaining tail

# interval_index: split by cumulative interval width
ix <- interval_index("A", "B", "C", start = c(0, 4, 9), end = c(3, 8, 10))
width_sum <- measure_monoid(`+`, 0, function(el) as.numeric(el$end - el$start))
ix2 <- add_monoids(ix, list(width_sum = width_sum))
cut_ix <- split_around_by_predicate(as_flexseq(ix2), function(v) v > 6, "width_sum")
cut_ix$left        # intervals before width budget is exceeded
cut_ix$elem        # first interval that crosses width budget (value at cut_ix$elem$item)
cut_ix$right       # remaining interval
}
\seealso{
[add_monoids.flexseq()], [add_monoids.priority_queue()],
  [add_monoids.ordered_sequence()], [add_monoids.interval_index()]
}
