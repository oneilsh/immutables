% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/30-api-flexseq-locate.R
\name{locate_by_predicate}
\alias{locate_by_predicate}
\title{Locate First Predicate Flip Without Reconstructing Context Trees}
\usage{
locate_by_predicate(
  t,
  predicate,
  monoid_name,
  accumulator = NULL,
  include_metadata = FALSE
)
}
\arguments{
\item{t}{A `flexseq`.}

\item{predicate}{Function on accumulated measure values.}

\item{monoid_name}{Name of monoid from `attr(t, "monoids")`.}

\item{accumulator}{Optional starting measure (defaults to monoid identity).}

\item{include_metadata}{Logical; include left/hit/right measures and index.}
}
\value{
If `include_metadata = FALSE`: `list(found, elem)`.
  If `TRUE`: `list(found, elem, metadata = list(left_measure, hit_measure,
  right_measure, index))`.
}
\description{
Read-only analogue of [split_around_by_predicate()]: finds the distinguished
element where the scan predicate flips, but does not rebuild left/right
trees.
}
\examples{
x <- as_flexseq(letters[1:6])
x

loc <- locate_by_predicate(x, function(v) v >= 4, ".size")
loc

# include metadata with a custom monoid
sum_m <- measure_monoid(`+`, 0, as.numeric)
x2 <- as_flexseq(1:6, monoids = list(sum = sum_m))
loc2 <- locate_by_predicate(x2, function(v) v >= 10, "sum", include_metadata = TRUE)
loc2
}
